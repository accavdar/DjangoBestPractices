<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">

    <title>Django Best Practices</title>

    <meta name="description" content="Django Best Practices Presentation">
    <meta name="author" content="Abdullah Cetin CAVDAR">
    <meta name="publisher" content="Udemy">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/css/theme/night.css" id="theme">
    <link rel="stylesheet" href="css/style.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="reveal/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write('<link rel="stylesheet" href="reveal/css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
    <script src="reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
    <h1>Django Best Practices</h1>

    <h3>March, 2014</h3>

    <p>
        <a href="http://www.linkedin.com/in/accavdar" target="_blank">Abdullah Cetin CAVDAR</a> / <a
            href="http://twitter.com/accavdar" target="_blank">@accavdar</a>
    </p>
</section>

<section>
    <p>This presentation is prepared based on the great book <a
            href="http://www.amazon.com/Two-Scoops-Django-Best-Practices/dp/1481879707">Two Scoops of Django:
        Best
        Practices For Django 1.5</a> by <a href="https://twitter.com/pydanny" target="_blank">Daniel
        Greenfeld</a> and
        <a href="https://twitter.com/audreyr" target="_blank">Audrey Roy</a>
    </p>
    <img src="img/two_scoops.png"/>
</section>

<section>
    <section>
        <h2>Core Concepts</h2>
    </section>

    <section>
        <h1>KISS</h1>

        <h2>Keep It Simple, Stupid</h2>
    </section>

    <section>
        <h2>Fat Models, Helper Modules, Thin Views, Stupid Templates</h2>
        <ul>
            <li class="fragment roll-in">Put more logic into anything but views and templates</li>
            <li class="fragment roll-in">Template tags and filters should contain the minimum logic possible
            </li>
        </ul>
    </section>

    <section>
        <h2>Start With Django by Default</h2>
        <ul>
            <li class="fragment roll-in">If we run into obstacles, we explore all possibilities before replacing core
                Django components
            </li>
        </ul>
    </section>
</section>

<section>

    <section>
        <h2>Coding Style</h2>
    </section>

    <section>
        <h2>The Importance of Making Your Code Readable</h2>
        <ul>
            <li class="fragment roll-in">
                Avoid abbreviating variable names
                <ul>
                    <li><span class="focus">Good:</span> balance_sheet_decrease</li>
                    <li><span class="focus">Bad:</span> bsd or bal_s_d</li>
                </ul>
            </li>
            <li class="fragment roll-in">Write out your function argument names</li>
            <li class="fragment roll-in">Document your classes and methods</li>
            <li class="fragment roll-in">Refactor repeated lines of code into reusable functions or methods</li>
        </ul>
    </section>

    <section>
        <h2>PEP8</h2>
        <ul>
            <li class="fragment roll-in">Use 4 spaces per indentation level</li>
            <li class="fragment roll-in">Separate top-level function and class definitions with two blank lines</li>
            <li class="fragment roll-in">Method definitions inside a class are separated by a single blank line</li>
        </ul>
    </section>

    <section>
        <h2>The Word on Imports</h2>

        <p>The Order:</p>
        <ul>
            <li class="fragment roll-in">Standard library imports</li>
            <li class="fragment roll-in">Imports from core Django</li>
            <li class="fragment roll-in">Imports from third-party apps</li>
            <li class="fragment roll-in">Imports from the apps that you created as part of your Django project</li>
        </ul>
    </section>

    <section>
        <h2>The Word on Imports</h2>
        <img src="img/imports.png"/>
    </section>

    <section>
        <h2>Use Explicit Relative Imports</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/hardcoded_import.png">
    </section>

    <section>
        <h2>Use Explicit Relative Imports</h2>

        <p class="success">Do this:</p>
        <img src="img/explicit_import.png">
    </section>

    <section>
        <h2>Import Types</h2>
        <img src="img/import_types.png">
    </section>

    <section>
        <h3><span class="focus">Get into the habit of using explicit relative imports.</span></h3>
    </section>

    <section>
        <h2>Avoid Using Import *</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/import_star.png">
    </section>

    <section>
        <h2>Avoid Using Import *</h2>

        <p>The reason for this is <span class="focus">to avoid implicitly loading all of another Python module’s locals into</span>
            and over <span class="focus">our current module’s namespace</span>, which can produce <span class="focus">unpredictable</span>
            and sometimes <span class="focus">catastrophic
            results</span>.</p>
    </section>

    <section>
        <h2>Django Coding Style Guidelines</h2>

        <ul>
            <li class="fragment roll-in">Use underscores (the '_' character) in URL pattern names rather than dashes as
                this is friendlier to more IDEs and text editors.
            </li>
            <li class="fragment roll-in">For the same reason, use underscores rather than dashes in template block
                names.
            </li>
            <li class="fragment roll-in">Follow the commonly used naming pattern of <span class="focus">&lt;app_name&gt;_tags.py</span>
                for template tags
            </li>

        </ul>

        <p class="fragment roll-in"><a
                href="https://docs.djangoproject.com/en/1.6/internals/contributing/writing-code/coding-style/"
                target="_blank">Django Coding Style Guidelines</a></p>
    </section>

    <section>
        <h2>Summary</h2>

        <ul>
            <li class="fragment roll-in">Follow a <span class="focus">consistent coding style</span></li>
            <li class="fragment roll-in">Projects with <span class="focus">varying styles</span> are <span
                    class="focus">much harder to maintain</span>, <span class="focus">slowing development</span> and
                <span class="focus">increasing the chances of developer mistakes</span></li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>The Optimal Django Environment Setup</h2>
    </section>

    <section>
        <h2>Use the Same Database Engine Everywhere</h2>

        <p>A common developer pitfall is using SQLite3 for local development and PostgreSQL (or another database besides
            SQLite3) in production.</p>

        <p class="focus">They may not behave identical in different environments.</p>
        <ul>
            <li class="fragment roll-in">Fixtures Are Not a Magic Solution</li>
            <li class="fragment roll-in">You Can’t Examine an Exact Copy of Production Data Locally</li>
            <li class="fragment roll-in">Different Databases Have Different Field Types/Constraints</li>
        </ul>
    </section>

    <section>
        <h2>Use <span class="focus">Pip</span> and <span class="focus">Virtualenv</span></h2>
        <ul>
            <li class="fragment roll-in"><span class="focus">Pip</span> is used to manage and install Python packages
            </li>
            <li class="fragment roll-in">Without <span class="focus">virtualenv</span> you have to update dependency
                versions every time you switch projects
            </li>
            <li class="fragment roll-in">If that sounds tedious, keep in mind that most real Django projects have at
                least a dozen dependencies to maintain
            </li>
            <li class="fragment roll-in"><span class="focus">$ source ~/Envs/udemy/bin/activate</span></li>
        </ul>
    </section>

    <section>
        <h2>Install Django and Other Dependencies via <span class="focus">Pip</span></h2>
    </section>

    <section>
        <h2>Use a Version Control System</h2>
    </section>
</section>

<section>
    <section>
        <h2>How to Layout Django Projects</h2>
    </section>

    <section>
        <h2>Prefered Project Layout</h2>
        <img src="img/project_layout.png"/>
    </section>

    <section>
        <h2>Top Level: Repository Root</h2>
        <ul>
            <li class="fragment roll-in">The top-level <span class="focus">&lt;repository_root&gt;/</span> directory is
                the absolute root directory of the project
            </li>
            <li class="fragment roll-in">Place other critical components like the <span class="focus">README.rst</span>,
                <span class="focus">docs/</span> directory, <span class="focus">design/</span> directory, <span
                        class="focus">.gitignore</span>, <span class="focus">requirements.txt</span> files, and other
                <span class="focus">high-level files</span> that are required for deployment
            </li>
        </ul>
    </section>

    <section>
        <h2>Second Level: Django Project Root</h2>
        <ul>
            <li class="fragment roll-in">This directory contains the
                <span class="focus">&lt;configuration_root&gt;</span>, <span class="focus">media</span> and <span
                        class="focus">static</span> directories, a <span class="focus">site-wide templates</span>
                directory, as well as <span class="focus">Django
                    apps</span> specific to your particular project
            </li>
        </ul>
    </section>

    <section>
        <h2>Third Level: Configuration Root</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">&lt;configuration_root&gt;</span> directory is where the <span class="focus">settings module</span>
                and base <span class="focus">URLConf (urls.py)</span> are placed
            </li>
            <li class="fragment roll-in">
                This must be a valid Python package (containing an <span class="focus">__init__.py</span> module)
            </li>
        </ul>
    </section>

    <section>
        <h2>Sample Project Layout</h2>
        <img src="img/sample_project_layout.png"/>
    </section>

    <section>
        <h2>What About the Virtualenv?</h2>
        <ul>
            <li class="fragment roll-in">
                Put all our environments in one directory and all our projects in another
            </li>
        </ul>
        <img src="img/vm_dirs.png" class="fragment roll-in"/>
    </section>

    <section>
        <h3>TIP: Listing Current Dependencies</h3>

        <h3><span class="focus">pip freeze --local</span></h3>
    </section>

    <section>
        <h2>Template to Generate Layout</h2>

        <p class="focus">django-admin.py startproject
            --template=https://github.com/twoscoops/django-twoscoops-project/zipball/master --extension=py,rst,html
            $project-name</p>
    </section>

    <section>
        <h2>Summary</h2>

        <p class="focus">Whatever layout is chosen should be documented clearly</p>
    </section>

</section>

<section>
    <section>
        <h2>Fundamentals of Django App Design</h2>
    </section>

    <section>
        <h2>Definitions</h2>
        <ul>
            <li class="fragment roll-in"><span class="focus">A Django project</span> is a web application powered by the
                Django web framework
            </li>
            <li class="fragment roll-in"><span class="focus">Django apps</span> are small libraries designed to
                represent a single aspect of a
                project. A Django project is made up of many Django apps. Some of those apps are internal to the project
                and will never be reused; others are third-party Django packages.
            </li>
            <li class="fragment roll-in"><span class="focus">Third-party Django packages</span> are simply pluggable,
                reusable Django apps that have been packaged with the Python packaging tools.
            </li>
        </ul>
    </section>

    <section>
        <h2>The Golden Rule of Django App Design</h2>
        <blockquote class="focus">"Write programs that do one thing and do it well"</blockquote>
    </section>

    <section>
        <h2>The Golden Rule of Django App Design</h2>

        <p><span class="focus">Each app should be tightly focused on its task</span></p>

        <p>If an app can’t be explained in a single sentence of moderate length, or you need to say 'and' more than
            once, it probably means the app is <span class="focus">too big</span> and should be <span class="focus">broken up</span>
        </p>
    </section>

    <section>
        <h2>What to Name Your Django Apps</h2>
        <ul>
            <li class="fragment roll-in">When possible keep to single word names like <span class="focus">flavors</span>,
                <span class="focus">animals</span>, <span class="focus">blog</span>, <span class="focus">polls</span>,
                <span class="focus">dreams</span>, <span class="focus">estimates</span>, and <span class="focus">finances</span>.
                A good, obvious app name makes the project easier to maintain
            </li>
            <li class="fragment roll-in">As a general rule, the app’s name should be a <span class="focus">plural version of the app’s main model</span>,
                but there are many good exceptions to this rule, blog being one of the most common ones
            </li>
            <li class="fragment roll-in">Use valid, PEP 8-compliant, importable Python package names: <span
                    class="focus">short,
                all-lowercase names without numbers, dashes, periods, spaces, or special characters</span>. If needed
                for
                readability, you can <span class="focus">use underscores to separate words</span>, although the use of
                underscores is discouraged
            </li>
        </ul>
    </section>

    <section>
        <h2>When in Doubt, Keep Apps Small</h2>

        <p class="focus">Try and keep your apps small. Remember, it’s better to have many small apps than to have a few
            giant apps.</p>
    </section>

    <section>
        <h2>Summary</h2>
        <ul>
            <li class="fragment roll-in">Each Django app should be <span
                    class="focus">tightly-focused on its own task</span>, <span class="focus">possess a simple, easy-to-remember name</span>
            </li>
            <li class="fragment roll-in">If an app seems too complex, it should be <span class="focus">broken up into smaller apps</span>
            </li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>Settings and Requirements Files</h2>
    </section>

    <section>
        <h2>Best Practices</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">All settings files need to be version-controlled</span>
                <ul>
                    <li>This is especially true in production environments, where dates, times, and explanations for
                        settings changes absolutely must be tracked
                    </li>
                </ul>
            </li>
            <li class="fragment roll-in">
                <span class="focus">Don’t Repeat Yourself</span>
                <ul>
                    <li>You should inherit from a base settings file rather than cutting-and-pasting from one file to
                        another
                    </li>
                </ul>
            </li>
            <li class="fragment roll-in">
                <span class="focus">Keep secret keys safe</span>
                <ul>
                    <li>They should be kept out of version control</li>
                </ul>
            </li>
        </ul>
    </section>

    <section>
        <h2>Avoid Non-Versioned Local Settings</h2>

        <p class="focus">Let’s break up development, staging, test, and production settings into separate components
            that inherit from a common base file all tracked by version control</p>
    </section>

    <section>
        <h2>Using Multiple Settings Files</h2>
        <img src="img/settings_dir.png"/>
    </section>

    <section>
        <img src="img/settings_purpose.png"/>
    </section>

    <section>
        <h4>TIP: Multiple Files with Continuous Integration Servers</h4>

        <p>You’ll also want to have a <span class="focus">ci.py</span> module containing that server’s settings.</p>
    </section>

    <section>
        <h2>Run Server</h2>

        <p class="focus">python manage.py runserver --settings=udemy.settings.local</p>
    </section>

    <section>
        <h2>--settings or DJANGO_SETTINGS_MODULE</h2>
        <img src="img/settings_config.png"/>
    </section>

    <section>
        <h2>DEV Settings Example</h2>
        <img src="img/dev_settings.png"/>
    </section>

    <section>
        <h3>Keep Secret Keys Out with Environment Variables</h3>
        <ul>
            <li class="fragment roll-in">
                Secrets often should be just that: secret! Keeping them in version control means that everyone with
                repository access has access to them
            </li>
            <li class="fragment roll-in">
                Secret keys are configuration values, not code
            </li>
        </ul>
    </section>

    <section>
        <h2>To resolve this, our answer is to use <span class="focus">environment variables</span></h2>
    </section>

    <section>
        <h2>Benefits of Using EV</h2>
        <ul>
            <li class="fragment roll-in">
                Keeping secrets out of settings allows you to store every settings file in version control without
                hesitation. All of your Python code really should be stored in version control, including your settings
            </li>
            <li class="fragment roll-in">
                Instead of each developer maintaining an easily-outdated, copy-and-pasted version of the
                <span class="focus">local_settings.py.example</span> file for their own development purposes, everyone
                shares the same
                version-controlled <span class="focus">settings/local.py</span>
            </li>
            <li class="fragment roll-in">
                System administrators can rapidly deploy the project without having to modify files containing Python
                code
            </li>
            <li class="fragment roll-in">
                Most platforms-as-a-service recommend the use of environment variables for configuration and have
                built-in features for setting and managing them
            </li>
        </ul>
    </section>

    <section>
        <h2>Local Settings & Usage</h2>
        <img src="img/ev.png"/>
        <img src="img/ev_in_code.png"/>
    </section>

    <section>
        <h2>Using Multiple Requirements Files</h2>
        <ul>
            <li class="fragment roll-in">
                First create a <span class="focus">requirements/</span> directory in the <span class="focus">&lt;repository_root&gt;</span>
            </li>
            <li class="fragment roll-in">
                Then create <span class="focus">'.txt'</span> files that match the contents of your settings directory
            </li>
        </ul>
        <img src="img/multiple_reqs.png" class="fragment roll-in">
    </section>

    <section>
        <h2>Sample Config</h2>

        <p class="focus">base.txt</p>
        <img src="img/base_reqs.png">

        <p class="focus">local.txt</p>
        <img src="img/local_reqs.png">
    </section>

    <section>
        <h2>Install From Reqs File</h2>

        <p class="focus">for development env</p>
        <img src="img/install_from_req_local.png">

        <p class="focus">for production env</p>
        <img src="img/install_from_req_prod.png">
    </section>

    <section>
        <h2>Handling File Paths in Settings</h2>

        <h3><span class="focus">Don't hardcode your paths</span></h3>
    </section>

    <section>
        <h2>Hardcoded Paths</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/hardcoded_paths.png">
    </section>

    <section>
        <h2>Relative Paths with Unipath</h2>

        <p class="success">Do this:</p>
        <img src="img/relative_paths.png">
    </section>

    <section>
        <h2>Relative Paths with Std Libs</h2>

        <p class="success">Do this:</p>
        <img src="img/relative_path_std.png">
    </section>

    <section>
        <h2>Summary</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">Everything except for critical security related values</span> ought to be <span
                    class="focus">tracked in version control</span>
            </li>
            <li class="fragment roll-in">
                Any project that’s destined for a real live production server is bound to need <span class="focus">multiple settings and
                requirements files</span>
            </li>
            <li class="fragment roll-in">
                The same thing applies to <span class="focus">requirements files</span>. Working with untracked
                dependency differences increases
                risk as much as untracked settings
            </li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>Database/Model Best Practices</h2>
    </section>

    <section>
        <h2>Basics</h2>
        <ul>
            <li class="fragment roll-in">
                Break Up Apps With Too Many Models
            </li>
            <li class="fragment roll-in">
                Don’t Drop Down to Raw SQL Until It’s Necessary
            </li>
            <li class="fragment roll-in">
                Add Indexes as Needed
            </li>
            <li class="fragment roll-in">
                Be Careful With Model Inheritance
            </li>
            <li class="fragment roll-in">
                Use South for Migrations
            </li>
        </ul>
    </section>

    <section>
        <h2>Condiser Adding Indexes?</h2>
        <ul>
            <li class="fragment roll-in">
                The index is used frequently, as in 10-25% of all queries
            </li>
            <li class="fragment roll-in">
                There is real data, or something that approximates real data, so we can analyze the results of indexing
            </li>
            <li class="fragment roll-in">
                We can run tests to determine if indexing generates an improvement in results
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">No Model Inheritance</span> if models have a common field, give both models that field
        </p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Makes it easiest to understand at a glance how Django models map to
                database tables
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> If there are a lot of fields duplicated across models, this can be hard
                to maintain
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">Abstract base classes</span> tables are only created for derived models
        </p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Having the common fields in an abstract parent class saves us from
                typing them more than once. We don’t get the overhead of extra tables and joins that are incurred from
                multi-table inheritance
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> We cannot use the parent class in isolation
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">Multi-table inheritance</span> tables are created for both parent and child. An implied
            <span class="focus">OneToOneField</span> links parent and child
        </p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Gives each model its own table, so that we can query either parent or
                child model. Also gives us the ability to get to a child object from a parent object: <span
                    class="focus">parent.child</span>
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> Adds substantial overhead since each query on a child table requires
                joins with all parent tables. <span class="focus">We strongly recommend against using multi-table inheritance</span>
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">Proxy Models</span> a table is only created for the original model</p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Allows us to have an alias of a model with different Python behavior
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> We cannot change the model’s fields
            </li>
        </ul>
    </section>

    <section>
        <h2>WARNING: Avoid Multi-Table Inheritance</h2>

        <p class="alert">Multi-table inheritance, sometimes called "concrete inheritance" is considered by the authors
            and many other
            developers to be a bad thing. We strongly recommend against using it</p>
    </section>

    <section>
        <h2>Django Model Design</h2>
    </section>

    <section>
        <h2>Design Basics</h2>
        <ul>
            <li class="fragment roll-in">
                Start Normalized
            </li>
            <li class="fragment roll-in">
                Cache Before Denormalizing
            </li>
            <li class="fragment roll-in">
                Denormalize Only if Absolutely Needed
            </li>
            <li class="fragment roll-in">
                When to Use Null and Blank
            </li>
        </ul>
    </section>

    <section>
        <h2>Null vs. Blank</h2>
        <img src="img/null_blank.png"/>
    </section>

    <section>
        <h2>Model Managers</h2>
    </section>

    <section>
        <h2>Model Managers Basics</h2>

        <p>Every time we use the Django ORM to query a model, we are using an interface called a <span class="focus">model manager</span>
            to interact with the database</p>

        <p>Django provides a default model manager for each model class, but we can define our own</p>
    </section>

    <section>
        <h2>Custom Model Manager</h2>
        <img src="img/custom_model_manager.png"/>
    </section>

    <section>
        <h2>Custom Model Manager</h2>
        <img src="img/model_manager_call.png"/>
    </section>

    <section>
        <h2>Summary</h2>
        <ul>
            <li class="fragment roll-in">
                Take the time to design models thoughtfully
            </li>
            <li class="fragment roll-in">
                Start normalized, and only denormalize if you’ve already explored other options thoroughly
            </li>
            <li class="fragment roll-in">
                Try to address your performance issues with caching
            </li>
            <li class="fragment roll-in">
                Don’t forget to use indexes. Add indexes when you have a better feel
            </li>
            <li class="fragment roll-in">
                If you decide to use model inheritance, inherit from abstract base classes rather than concrete models.
                You’ll save yourself from the confusion of dealing with implicit, unneeded joins
            </li>
            <li class="fragment roll-in">
                Use South to manage your data and schema migrations
            </li>
        </ul>
    </section>
</section>

<section>
    <section>
        <h2>Function- and Class- Based Views</h2>
    </section>

    <section>
        <h2>When to use FBV or CBVs</h2>
        <img src="img/fbc_vs_cbv.png"/>
    </section>

    <section>
        <h2>Keep View Logic Out of URLConfs</h2>
        <ul>
            <li class="fragment roll-in">
                The views modules should contain view logic
            </li>
            <li class="fragment roll-in">
                The URL modules should contain URL logic
            </li>
        </ul>
    </section>

    <section>
        <img src="img/bad_urls.png"/>
    </section>

    <section>
        <h2>Stick to Loose Coupling in <span class="focus">URLConfs</span></h2>
    </section>

    <section>
        <img src="img/good_view.png"/>
    </section>

    <section>
        <img src="img/good_urls.png"/>
    </section>

    <section>
        <h2>Best Practices</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">Don’t Repeat Yourself</span>: No argument or attribute is repeated between views
            </li>
            <li class="fragment roll-in">
                <span class="focus">Loose coupling</span>: We’ve removed the model and template names from the URLConf
                because views should be
                views and URLConfs should be URLConfs. We should be able to call our views from one or more URLConfs,
                and our approach lets us do just that
            </li>
            <li class="fragment roll-in">
                <span class="focus">URLConfs should do one thing and do it well: Related to our previous bullet, our URLConf is now focused
                primarily on just one thing</span>: URL routing. We aren’t tracking down view logic across both views
                and
                URLConfs, we just look in our views
            </li>
            <li class="fragment roll-in">
                <span class="focus">Our views benefit from being class-based</span>: Our views, by having a formal
                definition in the views module,
                can inherit from other classes. This means adding authentication, authorization, new content formats, or
                anything other business requirement tossed our way is much easier to handle
            </li>
            <li class="fragment roll-in">
                <span class="focus">Infinite flexibility</span>: Our views, by having a formal definition in the views
                module, can implement their
                own custom logic
            </li>
        </ul>
    </section>

    <section>
        <h2>Try to Keep Business Logic Out of Views</h2>
        <ul>
            <li class="fragment roll-in">
                Placing so much logic in our views made it much harder to deliver new formats such as PDF or REST API
            </li>
            <li class="fragment roll-in">
                Business logic is placed into easily reusable components, and called from within views, it makes
                extending components of the project to do more things much easier
            </li>
        </ul>
    </section>
</section>

<section>
    <section>
        <h2>Best Practices for Class-Based Views</h2>
    </section>

    <section>
        <h2>Guideline when writing CBVs</h2>
        <ul>
            <li class="fragment roll-in">
                Less view code is better
            </li>
            <li class="fragment roll-in">
                Never repeat code in views
            </li>
            <li class="fragment roll-in">
                Views should handle presentation logic. Try to keep business logic in models when possible, or in forms
                if you must
            </li>
            <li class="fragment roll-in">
                Keep your views simple
            </li>
            <li class="fragment roll-in">
                Keep your <span class="focus">mixins</span> simpler
            </li>
        </ul>
    </section>

    <section>
        <h2>Mixin Rules</h2>
        <ul>
            <li class="fragment roll-in">
                The base view classes provided by Django always go to the right
            </li>
            <li class="fragment roll-in">
                Mixins go to the left of the base view
            </li>
            <li class="fragment roll-in">
                Mixins should inherit from Python’s built-in object type
            </li>
        </ul>
    </section>

    <section>
        <img src="img/mixin.png"/>
    </section>

    <section>
        <h2>Django CBVs</h2>
        <img src="img/cbvs.png"/>
    </section>

    <section>
        <h3>Constraining Django CBV Access to Authenticated Users</h3>

        <p>PS: It uses <span class="focus">braces</span> lib</p>
        <img src="img/login_mixin.png">
    </section>
</section>

<section>
    <section>
        <h2>Things to Know About Forms</h2>
    </section>

    <section>
        <h2>Statistics</h2>
        <ul>
            <li class="fragment roll-in">
                95% of Django projects should use ModelForms
            </li>
            <li class="fragment roll-in">
                91% of all Django projects use ModelForms
            </li>
            <li class="fragment roll-in">
                80% of ModelForms require trivial logic
            </li>
            <li class="fragment roll-in">
                20% of ModelForms require complicated logic
            </li>
        </ul>
    </section>

    <section>
        <h2>Use the POST Method in HTML Forms</h2>

        <p class="focus">Every HTML form that alters data must submit its data via the POST method</p>

        <p class="focus">The only exception you’ll ever see to using POST in forms is with search forms, which typically
            submit queries that don’t result in any alteration of data.</p>
        <img src="img/form_post.png"/>
    </section>

    <section>
        <h3>Know How Form Validation Works</h3>

        <p>When you call <span class="focus">form.is_valid()</span>, a lot of things happen behind the scenes. The
            following things occur according to this workflow:</p>
        <ul>
            <li class="fragment roll-in">
                If the form has bound data, <span class="focus">form.is_valid()</span> calls the <span class="focus">form.full_clean()</span>
                method
            </li>
            <li class="fragment roll-in">
                <span class="focus">form.full_clean()</span> iterates through the form fields and each field validates
                itself:
                <ul>
                    <li>Data coming into the field is coerced into Python via the <span class="focus">to_python()</span>
                        method or raises a
                        <span class="focus">ValidationError</span>
                    </li>
                    <li>Data is validated against field-specific rules, including custom validators. Failure raises a
                        <span class="focus">ValidationError</span>
                    </li>
                    <li>If there are any custom <span class="focus">clean_
                        &lt;field&gt;()</span> methods in the form, they are called at this time
                    </li>
                </ul>
            </li>
            <li class="fragment roll-in">
                <span class="focus">form.full_clean()</span> executes the <span class="focus">form.clean()</span> method
            </li>
            <li class="fragment roll-in">
                If it’s a ModelForm instance, <span class="focus">form._post_clean()</span> does the following:
                <ul>
                    <li>Sets <span class="focus">ModelForm</span> data to the Model instance, regardless of whether
                        <span class="focus">form.is_valid()</span> is <span class="focus">True</span> or
                        <span class="focus">False</span>
                    </li>
                    <li>Calls the model’s <span class="focus">clean()</span> method. For reference, saving a model
                        instance through the ORM does
                        not call the model’s <span class="focus">clean()</span> method
                    </li>
                </ul>
            </li>
        </ul>
    </section>

    <section>
        <h3>Form Data Is Saved to the Form, Then the Model Instance</h3>
        <ul>
            <li class="fragment roll-in">
                First, form data is saved to the form instance
            </li>
            <li class="fragment roll-in">
                Later, form data is saved to the model instance
            </li>
        </ul>
    </section>

    <section>
        <h2>Summary</h2>

        <p class="focus">Once you dig into forms, keep yourself focused on clarity of code and testability</p>
    </section>

</section>

<section>
    <section>
        <h2>Building REST APIs in Django</h2>
    </section>

    <section>
        <h2>Fundamentals of Basic REST API Design</h2>
        <img src="img/http_methods.png"/>
    </section>

    <section>
        <h2>Notes</h2>
        <ul>
            <li class="fragment roll-in">
                If you’re implementing a read-only API, you might only need to implement GET methods
            </li>
            <li class="fragment roll-in">
                If you’re implementing a read-write API you must at least also use POST, but should also consider using
                PUT and DELETE
            </li>
            <li class="fragment roll-in">
                By definition, GET, PUT, and DELETE are idempotent. POST and PATCH are not
            </li>
            <li class="fragment roll-in">
                PATCH is often not implemented, but it’s a good idea to implement it if your API supports PUT requests
            </li>
        </ul>
    </section>

    <section>
        <h2>Status Codes</h2>
        <img src="img/status_codes.png"/>
    </section>

    <section>
        <h3>Implementing a Simple JSON API</h3>

        <p>Use <span class="focus">django-rest-framework</span></p>
    </section>

    <section>
        <img src="img/rest_model.png"/>
    </section>

    <section>
        <img src="img/rest_views.png"/>
    </section>

    <section>
        <img src="img/rest_urls.png"/>
    </section>

    <section>
        <img src="img/rest_mapping.png"/>
    </section>

    <section>
        <h2>REST API Architecture</h2>
    </section>

    <section>
        <h3>Code for an App Should Remain in the App</h3>

        <p class="focus">REST API views should go into views.py modules and follow the same guidelines we endorse when
            it comes to any other view</p>

        <p class="focus">The same goes for app or model specific serializers and renderers.</p>
    </section>

    <section>
        <h3>Try to Keep Business Logic Out of API Views</h3>

        <p class="focus">It’s a good idea to try to keep as much logic as possible out of API views</p>
    </section>

    <section>
        <h3>Grouping API URLs</h3>

        <p class="focus">How do you build a project-wide API that looks like this?</p>
        <img src="img/project_wide_api.png"/>

    </section>

    <section>
        <h3>Solution</h3>

        <p>When building a project-wide API we write the REST views in the <span class="focus">views.py</span> modules,
            wire them into a <span class="focus">URLConf</span>
            called something like <span class="focus">core/api.py</span> or <span class="focus">core/apiv1.py</span> and
            include that from the project root’s <span class="focus">urls.py</span>
            module</p>
    </section>

    <section>
        <img src="img/rest_url_grouping.png"/>
    </section>
</section>

<section>
    <section>
        <h2>Templates: Best Practices</h2>
    </section>

    <section>
        <h2>Follow a Minimalist Approach</h2>

        <p class="focus">Find simple, elegant ways to put more of your business logic into Python code rather than into
            templates</p>
    </section>

    <section>
        <h3>Template Architecture Patterns</h3>
        <ul>
            <li class="fragment roll-in">
                2-Tier Template Architecture Example
            </li>
            <li class="fragment roll-in">
                3-Tier Template Architecture Example
            </li>
        </ul>
    </section>

    <section>
        <h2>2-Tier Template Architecture Example</h2>
        <img src="img/two_tier.png"/>
    </section>

    <section>
        <h2>3-Tier Template Architecture Example</h2>
        <img src="img/three_tier.png"/>
    </section>

    <section>
        <h2>Flat Is Better Than Nested</h2>

        <p class="focus">Complex template hierarchies make it exceedingly difficult to debug, modify, and extend HTML
            pages and tie in CSS styles</p>

        <p class="focus">When you have large, multi-line chunks of the same or very similar code in separate templates,
            refactoring that code into reusable blocks will make your code more maintainable. </p>
    </section>

    <section>
        <h2>Template Best Practices</h2>
        <ul>
            <li class="fragment roll-in">
                Limit Processing in Templates
                <ul>
                    <li>Try to think about caching to handle template inefficiencies</li>
                </ul>
            </li>
            <li class="fragment roll-in">
                Don't Aggregate in Templates
                <ul>
                    <li>Ex: Birth Date -> Age</li>
                </ul>
            </li>
            <li class="fragment roll-in">
                Don't Filter With Conditionals in Templates
            </li>
            <li class="fragment roll-in">
                Don't Use Complex Implied Queries in Templates
            </li>
            <li class="fragment roll-in">
                Avoid Hidden CPU Load in Templates
                <ul>
                    <li>Ex: Take image processing out of templates and into views, models, helper methods, or
                        asynchronous messages queues like Celery
                    </li>
                </ul>
            </li>

            <li class="fragment roll-in">
                Avoid Hidden REST API Calls in Templates
                <ul>
                    <li>An example is querying an unfortunately slow maps API hosted by a third-party service</li>
                </ul>
            </li>
        </ul>
    </section>

    <section>
        <h2>Don't Filter With Conditionals in Templates</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/conditonal_templates.png">
    </section>

    <section>
        <h2>Don't Filter With Conditionals in Templates</h2>

        <p class="success">Do this:</p>
        <img src="img/conditonal_templates2.png">
    </section>

    <section>
        <h2>Don't Filter With Conditionals in Templates</h2>

        <p class="success">Do this:</p>
        <img src="img/conditonal_templates3.png">
    </section>

    <section>
        <h2>Don't Use Complex Implied Queries in Templates</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/complex_queries.png">
    </section>

    <section>
        <h2>Don't Use Complex Implied Queries in Templates</h2>

        <p>Use <span class="focus">select_related()</span> method</p>

        <p class="success">Do this:</p>
        <img src="img/complex_queries2.png">
    </section>

    <section>
        <h2>Exploring Template Inheritance</h2>
        <img src="img/template_inheritance.png"/>
    </section>

    <section>
        <h2>Template Tags</h2>
        <img src="img/template_tags.png"/>
    </section>

    <section>
        <img src="img/template_inheritance3.png"/>
    </section>

    <section>
        <img src="img/template_inheritance4.png"/>
    </section>

    <section>
        <h2>Template Objects</h2>
        <img src="img/template_objects.png"/>
    </section>

    <section>
        <h3>{block super}</h3>

        <p><img src="img/block_super.png"/></p>

        <p><img src="img/block_super2.png"/></p>
    </section>

    <section>
        <h3>Use URL Names Instead of Hardcoded Paths</h3>

        <p><img src="img/url_names.png"/></p>

        <p><img src="img/url_names2.png"/></p>
    </section>

</section>

<section>
    <section>
        <h2>Trade offs of Replacing Core Components</h2>
    </section>

    <section>
        <h3><span class="focus">Short Answer: Don’t do it</span></h3>
        <img src="img/replacing_core_components.png"/>
    </section>

</section>

<section>
    <section>
        <h2>Dealing with the User Model</h2>
    </section>

    <section>
        <h2>Finding the User Model</h2>
        <img src="img/finding_user_model.png"/>
    </section>

    <section>
        <h3>Use <span class="focus">settings.AUTH_USER_MODEL</span> for Foreign Keys</h3>
        <img src="img/auth_user_model.png"/>
    </section>

    <section>
        <h3>Custom User Model</h3>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">Option 1</span>: Linking Back From a Related Model
            </li>
            <li class="fragment roll-in">
                <span class="focus">Option 2</span>: Subclass <span class="focus">AbstractUser</span>
            </li>
            <li class="fragment roll-in">
                <span class="focus">Option 3</span>: Subclass <span class="focus">AbstractBaseUser</span>
            </li>
        </ul>
    </section>

    <section>
        <h3>Linking Back From a Related Model</h3>
        <img src="img/user_model1.png"/>
    </section>

    <section>
        <h3>Subclass <span class="focus">AbstractUser</span></h3>

        <p><img src="img/user_model2.png"/></p>

        <p><img src="img/user_model2_settings.png"/></p>
    </section>

    <section>
        <h3>Subclass <span class="focus">AbstractBaseUser</span></h3>

        <p><span class="focus">AbstractBaseUser</span> is the bare-bones option with only 3 fields: <span class="focus">password</span>,
            <span class="focus">last_login</span>, and <span class="focus">is_active</span></p>

        <p class="fragment roll-in">Choose this option if:</p>
        <ul>
            <li class="fragment roll-in">
                You’re unhappy with the fields that the User model provides by default, such as <span class="focus">first_name</span>
                and <span class="focus">last_name</span>
            </li>
            <li class="fragment roll-in">
                You prefer to subclass from an extremely bare-bones clean slate but want to take advantage of the <span
                    class="focus">AbstractBaseUser</span> sane default approach to storing passwords
            </li>
        </ul>

        <p class="fragment roll-in"><a
                href="https://docs.djangoproject.com/en/1.6/topics/auth/customizing/#a-full-example">Official Doc:
            Customizing User</a></p>
    </section>

    <section>
        <img src="img/user_model3.png"/>
    </section>

    <section>
        <h2>Summary</h2>

        <p class="focus">Depending on the needs of a project, they can either continue with the current way of doing
            things or customize the actual user model</p>
    </section>

</section>

<section>
    <section>
        <h2>Testing</h2>
    </section>

    <section>
        <h3>Useful Libraries For Testing Django Projects</h3>

        <p>Use <span class="focus">coverage.py</span> and <span class="focus">django-discover-runner</span></p>
    </section>

    <section>
        <h3>How to Structure Tests</h3>

        <p>The first thing we do is delete the default but useless <span class="focus">tests.py</span> module that <span
                class="focus">django-admin.py startapp</span> creates</p>

        <p>In its place, we create a tests directory and place an <span class="focus">__init__.py</span> file in it so
            it becomes a valid Python
            module. Then, inside the new tests module, because most apps need them, we create <span class="focus">test_forms.py</span>,
            <span class="focus">test_models.py</span>, <span class="focus">test_views.py</span> modules. Tests that
            apply to forms go into <span class="focus">test_forms.py</span>, model tests go into
            <span class="focus">test_models.py</span>, and so on</p>
    </section>

    <section>
        <h3>Test Structure</h3>
        <img src="img/test_structure.png"/>
    </section>

    <section>
        <h3>TIP: Prefix Test Modules With <span class="focus">test_</span></h3>

        <p>It’s critically important that we always prefix test modules with <span class="focus">test_</span>, otherwise
            we can’t configure
            django-discover-runner to discover just our test files.</p>
    </section>

    <section>
        <h2>How to Write Unit Tests</h2>
    </section>

    <section>
        <h3>Each Test Method Tests One Thing</h3>

        <p class="focus">A single test should assert the behavior of a single view, model, form, method or function</p>

        <p class="focus">Be absolutely minimalistic when constructing the environment</p>
        <img src="img/test_case.png"/>

    </section>

    <section>
        <h3>Don’t Write Tests That Have to Be Tested</h3>

        <p class="focus">Tests should be written as simply as possible. If the code in a test or called to help run a
            test feels complicated or abstracted, then you have a problem</p>

        <p class="focus">Don’t Repeat Yourself Doesn’t Apply to Writing Tests </p>
    </section>

    <section>
        <h3>PACKAGE TIP: Tools to Generate Test Data</h3>

        <ul>
            <li class="fragment roll-in">
                <span class="focus">factory_boy</span> A package that generates model test data
            </li>
            <li class="fragment roll-in">
                <span class="focus">model_mommy</span> Another package that generates model test data
            </li>
            <li class="fragment roll-in">
                <span class="focus">mock</span> Not explicitly for Django, this allows you to replace parts of your
                system with mock objects
            </li>
        </ul>
    </section>

    <section>
        <h3>Things That Should Be Tested</h3>

        <h2><span class="focus">Everything</span></h2>

        <p class="focus">Views, Models, Forms, Validators, Filters, Signals, Template Tags, ...</p>
    </section>

    <section>
        <h3>Continuous Integration (CI)</h3>

        <p class="focus">For medium and large projects, we recommend setting up a continuous integration (CI) server to
            run the project’s test suite whenever code is committed and pushed to the project repo</p>
    </section>

    <section>
        <h3>Test Coverage</h3>

        <p class="focus">Try to get test coverage as high as possible. Every work day we increase our test coverage is a
            victory, and every day the coverage goes down is a loss</p>
    </section>

    <section>
        <h3>Setup a Test Runner</h3>

        <p>Create a <span class="focus">settings/test.py</span> module and add the following</p>
        <img src="img/test_config.png"/>
    </section>

    <section>
        <h3>Run Tests and Generate Coverage Report</h3>

        <p><img src="img/test_coverage.png"/></p>

        <p><img src="img/execute_tests.png"/></p>
    </section>

    <section>
        <h3>Generate Report</h3>

        <img src="img/generate_report.png"/>
    </section>

    <section>
        <h3>Playing the Game of Test Coverage</h3>

        <p class="focus">The game has a single rule:</p>

        <h3><span class="focus">Mandate that no commit can lower test coverage</span></h3>
    </section>

</section>

<section>
    <section>
        <h2>Finding and Reducing Bottlenecks</h2>
    </section>

    <section>
        <h3>Speed Up Query-Heavy Pages</h3>
        <ul>
            <li class="fragment roll-in">
                Use <span class="focus">django-debug-toolbar</span> to help you determine where most of your queries are
                coming from. Configure it to include the <span class="focus">SQLDebugPanel</span>
            </li>
            <li class="fragment roll-in">
                Add <span class="focus">django-cache-panel</span> to your project, but only configured to run when <span
                    class="focus">settings/dev.py</span> module is
                called. This will increase visibility into what your cache is doing
            </li>
            <li class="fragment roll-in">
                <span class="focus">django-extensions</span> comes with a tool called <span class="focus">RunProfileServer</span>
                that starts Django’s runserver command with hotshot/profiling tools enabled
            </li>
            <li class="fragment roll-in">
                Reduce the Number of Queries
                <ul>
                    <li>Use <span class="focus">select_related()</span> in your ORM</li>
                    <li>Implement caching using a key/value store such as <span class="focus">Memcached</span></li>
                </ul>
            </li>
            <li class="fragment roll-in">
                Speed Up Common Queries
            </li>
        </ul>
    </section>

    <section>
        <h3>TIP: Use EXPLAIN ANALYZE / EXPLAIN</h3>

        <p>If you’re using PostgreSQL, you can use <span class="focus">EXPLAIN ANALYZE</span> to get an extremely
            detailed query plan and analysis
            of any raw SQL query. The MySQL equivalent is the <span class="focus">EXPLAIN</span> command, which isn’t as
            detailed but is still
            helpful</p>
    </section>

    <section>
        <h3>Get the Most Out of Your Database</h3>
        <ul>
            <li class="fragment roll-in">
                Don’t add logs to the database. They will slow DB performance
            </li>
            <li class="fragment roll-in">
                Don’t store ephemeral data in the database. This includes examples such as <span class="focus">django.contrib.sessions</span>,
                <span class="focus">django.contrib.messages</span>, and <span class="focus">metrics</span>. Instead,
                move this data to things like <span class="focus">Memcached</span>, <span class="focus">Redis</span>,
                <span class="focus">Riak</span>, and <span class="focus">other non-relational stores</span>
            </li>
            <li class="fragment roll-in">
                Try performance tuning for your database (ex: MySQL)
            </li>
        </ul>
    </section>

    <section>
        <h3>Cache Queries With Memcached or Redis</h3>

        <p class="focus">Simply setting up Django’s built-in caching system with Memcached or Redis</p>
    </section>

    <section>
        <h3>Identify Specific Places to Cache</h3>
        <ul>
            <li class="fragment roll-in">
                Which views/templates contain the most queries?
            </li>
            <li class="fragment roll-in">
                Which URLs are being requested the most?
            </li>
            <li class="fragment roll-in">
                When should a cache for a page be invalidated?
            </li>
        </ul>
    </section>

    <section>
        <h3>Consider Third-Party Caching Packages</h3>

        <p class="focus">Additional Features of 3rd party packages:</p>
        <ul>
            <li class="fragment roll-in">
                Caching of QuerySets
            </li>
            <li class="fragment roll-in">
                Cache invalidation settings/mechanisms
            </li>
            <li class="fragment roll-in">
                Alternative or experimental approaches to caching
            </li>
            <li class="fragment roll-in">
                Ex: <span class="focus">django-cache-machine</span>, <span class="focus">johnny-cache</span>
            </li>
        </ul>
    </section>

    <section>
        <h3>Compression and Minification of HTML, CSS, and JavaScript</h3>

        <p class="focus">Django provides tools for you: GZipMiddleware and the {% spaceless %} template tag. However,
            compression and
            minification take up system resources, which can create bottlenecks of their own</p>

        <p>A better approach is to use <span class="focus">Apache</span> and <span class="focus">Nginx</span> web
            servers configured to compress the outgoing content</p>
    </section>

    <section>
        <h3>Use Upstream Caching or a Content Delivery Network</h3>

        <p><span class="focus">Upstream caches</span> such as <span class="focus">Varnish</span> are very useful. They
            run in front of your web server and speed up web page
            or content serving significantly</p>

        <p><span class="focus">Content Delivery Networks (CDNs)</span> like <span class="focus">Akamai</span> and <span
                class="focus">Amazon Cloudfront</span> serve static media such as images, video,
            CSS, and JavaScript files</p>
    </section>
</section>

<section>
<section>
    <h2>Security Best Practices</h2>
</section>

<section>
    <h3>Harden Your Servers</h3>

    <p class="focus">Change your SSH port and disable/remove unnecessary services</p>
</section>

<section>
    <h3>Know Django’s Security Features</h3>

    <p class="focus">Django has lots of security features. Know how to configure them. Django security features
        include:</p>

    <ul>
        <li class="fragment roll-in">
            Cross-site scripting (XSS) protection
        </li>
        <li class="fragment roll-in">
            Cross-site request forgery (CSRF) protection
        </li>
        <li class="fragment roll-in">
            SQL injection protection
        </li>
        <li class="fragment roll-in">
            Clickjacking protection
        </li>
        <li class="fragment roll-in">
            Support for SSL/HTTPS, including secure cookies
        </li>
        <li class="fragment roll-in">
            Validation of files uploaded by users
        </li>
        <li class="fragment roll-in">
            Secure password storage, using the PBKDF2 algorithm with a SHA256 hash by default
        </li>
        <li class="fragment roll-in">
            Automatic HTML escaping
        </li>
    </ul>
</section>

<section>
    <h3>Turn Off DEBUG Mode in Production</h3>

    <p class="focus">Your production site should not be running in DEBUG mode</p>
</section>

<section>
    <h3>Keep Your Secret Keys Secret</h3>

    <p class="focus">Keep Secret Keys Out With Environment Variables</p>
</section>

<section>
    <h3>HTTPS Everywhere</h3>
    <ul>
        <li class="fragment roll-in">
            It is always better to deploy a site behind <span class="focus">HTTPS</span>
        </li>
        <li class="fragment roll-in">
            Two packages that force HTTPS/SSL across your entire site through Django middleware
            <ul>
                <li><a href="https://github.com/rdegges/django-sslify">django-sslify</a></li>
                <li><a href="https://github.com/carljm/django-secure">django-secure</a></li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h3>Use HTTP Strict Transport Security (HSTS)</h3>

    <p class="focus">When you enable HSTS, your site’s web pages include a HTTP header that tells HSTS-compliant
        browsers to only connect to the site via secure connections:</p>


    <img src="img/secure_cookies.png"/>
</section>

<section>
    <h3>Use Secure Cookies</h3>

    <p class="focus">Your site’s cookies should also be served over HTTPS. You’ll need to set the following in your
        settings:</p>
    <ul>
        <li>
            HSTS-compliant browsers will redirect HTTP links to HTTPS
        </li>
        <li>
            If a secure connection isn’t possible (e.g. the certificate is self-signed or expired), an error message
            will be shown and access will be disallowed
        </li>
    </ul>

    <img src="img/hsts.png"/>
</section>

<section>
    <h3>Use Django’s Allowed Hosts Validation</h3>

    <p>You must set <span class="focus">ALLOWED_HOSTS</span> in your settings to a list of allowed host/domain
        names. This is a security measure to prevent use of fake HTTP Host headers to submit requests</p>
</section>

<section>
    <h3>Always Use CSRF Protection With HTTP Forms That Modify Data</h3>

    <p>Django comes with <span class="focus">Cross-site Request Forgery Protection (CSRF)</span> built in</p>

    <p>You should use Django’s <span class="focus">CsrfViewMiddleware</span> as blanket protection across your site
        rather than manually decorating views with <span class="focus">csrf_protect</span></p>
</section>

<section>
    <h3>Prevent Against Cross-Site Scripting (XSS) Attacks</h3>

    <p class="focus">Django by default escapes a lot of specific characters meaning most attacks fail</p>
</section>

<section>
    <h3>Defend Against Python Code Injection Attacks</h3>
    <ul>
        <li class="fragment roll-in">
            Beware of the <span class="focus">eval()</span>, <span class="focus">exec()</span>, and <span
                class="focus">execfile()</span> built-ins. If your project allows arbitrary strings or
            files to be passed into any of these functions, you are leaving your system open to attack
        </li>
        <li class="fragment roll-in">
            Never unpickle data received from an untrusted or unauthenticated source
        </li>
        <li class="fragment roll-in">
            Validate All User Input With Django Forms
        </li>
    </ul>
</section>

<section>
    <h3>Handle User-Uploaded Files Carefully</h3>
    <ul>
        <li class="fragment roll-in">Pay close attention to where you’re uploading them and what type of files they
            are, to avoid
            security holes
        </li>
        <li class="fragment roll-in">
            Use the <span class="focus">python-magic</span> library to check the uploaded file’s headers
        </li>
    </ul>
</section>

<section>
    <h3>Don’t Use ModelForms.Meta.exclude</h3>

    <p>When using <span class="focus">ModelForms</span>, always use <span class="focus">Meta.fields</span>. Never
        use <span class="focus">Meta.exclude</span>. The use of <span class="focus">Meta.exclude</span> is
        considered a grave security risk. We can’t stress this strongly enough. <span
                class="alert">Don’t do it</span></p>
</section>

<section>
    <h3>Meta.fields vs. Meta.exclude</h3>

    <p><img src="img/meta_exclude.png"/></p>

    <p><img src="img/meta_fields.png"/></p>
</section>

<section>
    <h3>Beware of SQL Injection Attacks</h3>

    <p class="focus">The Django ORM generates properly-escaped SQL which will protect your site from users
        attempting to execute malignant, arbitrary SQL code</p>

    <p class="focus">When using raw SQL, be especially careful to escape your SQL code properly</p>
</section>

<section>
    <h3>Never Store Credit Card Data</h3>

    <p class="focus">We recommend using third-party services like Stripe, Balanced Payments, PayPal, and others that
        handle storing this information for you</p>
</section>

<section>
    <h3>Secure the Django Admin</h3>

    <p class="focus">Since the Django admin gives your site admins special powers that ordinary users don’t have, it’s
        good practice to make it extra secure</p>

    <ul>
        <li class="fragment roll-in">
            Change the Default Admin URL
        </li>
        <li class="fragment roll-in">
            Use <span class="focus">django-admin-honeypot</span>
        </li>
        <li class="fragment roll-in">
            Only Allow Admin Access via HTTPS
        </li>
        <li class="fragment roll-in">
            Limit Admin Access Based on IP
        </li>
    </ul>
</section>

<section>
    <h3>Monitor Your Sites</h3>

    <p class="focus">Check your web servers’ access and error logs regularly. Install monitoring tools and check on them
        frequently</p>
</section>

<section>
    <h3>Keep Your Dependencies Up-to-Date</h3>

    <p class="focus">You should always update your projects to work with the latest stable release of Django. This is
        particularly important when a release includes security fixes</p>
</section>

<section>
    <h3>Put Up a Vulnerability Reporting Page</h3>

    <p class="focus">It’s a good idea to publish information on your site about how users can report security
        vulnerabilities to you</p>
</section>
</section>

<section>
    <section>
        <h2>Logging</h2>
    </section>

    <section>
        <h3>When to Use Each Log Level</h3>

        <p class="focus">LOG Levels: DEBUG, INFO, WARNING, ERROR, and CRITICAL</p>

        <p>In your production environment, we recommend using every log level except for <span
                class="focus">DEBUG</span></p>
        <img src="img/log_levels.png"/>
    </section>

    <section>
        <h3>Log Catastrophes With <span class="focus">CRITICAL</span></h3>

        <p class="focus">Ex: if your code relies on an internal web service being available, and if that web service is
            part of your site’s core functionality, then you might log at the CRITICAL level anytime that the web
            service is inaccessible</p>
    </section>

    <section>
        <h3>Log Production Errors With <span class="focus">ERROR</span></h3>

        <p class="focus">We recommend that you use the ERROR log level whenever you need to log an error that
            is worthy of being emailed to you or your site admins</p>
    </section>

    <section>
        <h3>Log Lower-Priority Problems With <span class="focus">WARNING</span></h3>

        <p class="focus">This level is good for logging events that are unusual and potentially bad, but not as bad as
            ERROR-level events</p>

        <p>Ex: if you are using <span class="focus">django-admin-honeypot</span> to set up a fake <span class="focus">admin/</span>
            login form, you might want to log intruders' login attempts to this level</p>
    </section>

    <section>
        <h3>Log Useful State Information With <span class="focus">INFO</span></h3>
        <ul>
            <li class="fragment roll-in">
                Startup and shutdown of important components not logged elsewhere
            </li>
            <li class="fragment roll-in">
                State changes that occur in response to important events
            </li>
            <li class="fragment roll-in">
                Changes to permissions, e.g. when users are granted admin access
            </li>
        </ul>
    </section>

    <section>
        <h3>Log Debug-Related Messages to <span class="focus">DEBUG</span></h3>

        <p><img src="img/log_print.png"/></p>

        <p><img src="img/log_debug.png"/></p>
    </section>

    <section>
        <h3>Log Tracebacks When Catching Exceptions</h3>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">Logger.exception()</span> automatically includes the traceback and logs at <span
                    class="focus">ERROR</span> level
            </li>
            <li class="fragment roll-in">
                For other log levels, use the optional <span class="focus">exc_info keyword</span> argument
            </li>
        </ul>
        <img class="fragment roll-in" src="img/log_trackbacks.png"/>
    </section>

    <section>
        <h3>One Logger Per Module That Uses Logging</h3>

        <p>Whenever you use logging in another module, don’t import and reuse a logger from elsewhere. Instead, define a
            new logger specific to the module like this</p>
        <img src="img/logger_per_module.png"/>
    </section>

    <section>
        <h3>Log Locally to Rotating Files</h3>

        <p>A common way to set up log rotation is to use the UNIX <span class="focus">logrotate</span> utility with
            <span class="focus">logging.handlers.WatchedFileHandler</span></p>
    </section>

    <section>
        <h3>Other Logging Tips</h3>
        <ul>
            <li class="fragment roll-in">
                Control the logging in settings files per the Django documentation on logging
            </li>
            <li class="fragment roll-in">
                While debugging, use the Python logger at <span class="focus">DEBUG</span> level
            </li>
            <li class="fragment roll-in">
                After running tests at <span class="focus">DEBUG</span> level, try running them at <span class="focus">INFO</span>
                and <span class="focus">WARNING</span> levels. The reduction in information you see may help you
                identify upcoming deprecations for third-party libraries
            </li>
            <li class="fragment roll-in">
                Don’t wait until it’s too late to add logging. You’ll be grateful for your logs if and when your site
                fails
            </li>
            <li class="fragment roll-in">
                Use <span class="focus">logutils</span> utility for advanced logging features
            </li>
        </ul>
    </section>
</section>

<section>
    <section>
        <h2>Random Utilities</h2>
    </section>

    <section>
        <h3>Create a Core App for Your Utilities</h3>

        <p>Our way of handling our utilities is to place them into a Django app called <span class="core">core</span>
            that contains modules which contains functions and objects for use across a project</p>
        <img src="img/core_app.png"/>
    </section>

    <section>
        <h3>Django’s Own Swiss Army Knife</h3>

        <p>Django has a number of useful helper functions that don’t have a better home than the <span class="core">django.utils</span>
            package</p>
    </section>

    <section>
        <h3>django.contrib.humanize</h3>

        <p class="focus">his is a set of localized template filters designed to give user presented data a more 'human'
            touch</p>
    </section>

    <section>
        <h3>django.utils.html.remove_tags(value, tags)</h3>

        <p class="focus">When you need to accept content from users and want to strip out a list of tags, this function
            removes those tags for you while keeping all other content untouched</p>
    </section>

    <section>
        <h3>django.utils.html.strip_tags(value)</h3>

        <p class="focus">When you need to accept content from users and have to strip out anything that could be HTML,
            this function removes those tags for you while keeping all the existing text between tags</p>
    </section>

    <section>
        <h3>django.utils.text.slugify(value)</h3>

        <p>Whatever you do, don’t write your own version of the <span class="focus">slugify()</span> function; as any
            inconsistency from what
            Django does with this function will cause subtle yet nasty problems. Instead, use the same function that
            Django uses and <span class="focus">slugify()</span> consistently</p>
    </section>

    <section>
        <h3>django.utils.timezone</h3>

        <p class="focus">When you use Django’s time zone support, date and time information is stored in the database
            uniformly in UTC format and converted to local time zones as needed</p>
    </section>

    <section>
        <h3>django.utils.translation</h3>

        <p class="focus">Much of the non-English speaking world appreciates use of this tool, as it provides Django’s
            i18n support</p>
    </section>
</section>

<section>
    <section>
        <h2>Deploying Django Projects</h2>
    </section>

    <section>
        <h2>Using Your Own Web Servers</h2>

        <p>You should deploy your Django projects with <span class="focus">WSGI</span></p>

        <p class="focus">Most common setup:</p>

        <ul>
            <li class="fragment roll-in">
                <span class="focus">Gunicorn</span> behind a <span class="focus">Nginx</span> proxy
            </li>
            <li class="fragment roll-in">
                <span class="focus">Apache</span> with <span class="focus">mod_wsgi</span>
            </li>
        </ul>
    </section>

    <section>
        <h2>Quick Comparison</h2>
        <img src="img/deployment.png"/>
    </section>
</section>

</div>
</div>

<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>

<script>
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme,
        transition: Reveal.getQueryHash().transition || 'zoom', // default/cube/page/concave/zoom/linear/fade/none

        dependencies: [
            { src: 'reveal/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            } },
            { src: 'reveal/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'reveal/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            } },
            { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function () {
                return !!document.body.classList;
            } },
            { src: 'reveal/plugin/notes/notes.js', async: true, condition: function () {
                return !!document.body.classList;
            } }
        ]
    });
</script>
</body>
</html>

