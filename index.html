<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">

    <title>Django Best Practices</title>

    <meta name="description" content="Django Best Practices Presentation">
    <meta name="author" content="Abdullah Cetin CAVDAR">
    <meta name="publisher" content="Udemy">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/css/theme/night.css" id="theme">
    <link rel="stylesheet" href="css/style.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="reveal/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write('<link rel="stylesheet" href="reveal/css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
    <script src="reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
    <h1>Django Best Practices</h1>

    <h3>March, 2014</h3>

    <p>
        <a href="http://www.linkedin.com/in/accavdar" target="_blank">Abdullah Cetin CAVDAR</a> / <a
            href="http://twitter.com/accavdar" target="_blank">@accavdar</a>
    </p>
</section>

<section>
    <p>This presentation is prepared based on the great book <a
            href="http://www.amazon.com/Two-Scoops-Django-Best-Practices/dp/1481879707">Two Scoops of Django:
        Best
        Practices For Django 1.5</a> by <a href="https://twitter.com/pydanny" target="_blank">Daniel
        Greenfeld</a> and
        <a href="https://twitter.com/audreyr" target="_blank">Audrey Roy</a>
    </p>
    <img src="img/two_scoops.png"/>
</section>

<section>
    <section>
        <h2>Core Concepts</h2>
    </section>

    <section>
        <h1>KISS</h1>

        <h2>Keep It Simple, Stupid</h2>
    </section>

    <section>
        <h2>Fat Models, Helper Modules, Thin Views, Stupid Templates</h2>
        <ul>
            <li class="fragment roll-in">Put more logic into anything but views and templates</li>
            <li class="fragment roll-in">Template tags and filters should contain the minimum logic possible
            </li>
        </ul>
    </section>

    <section>
        <h2>Start With Django by Default</h2>
        <ul>
            <li class="fragment roll-in">If we run into obstacles, we explore all possibilities before replacing core
                Django components
            </li>
        </ul>
    </section>
</section>

<section>

    <section>
        <h2>Coding Style</h2>
    </section>

    <section>
        <h2>The Importance of Making Your Code Readable</h2>
        <ul>
            <li class="fragment roll-in">
                Avoid abbreviating variable names
                <ul>
                    <li><span class="focus">Good:</span> balance_sheet_decrease</li>
                    <li><span class="focus">Bad:</span> bsd or bal_s_d</li>
                </ul>
            </li>
            <li class="fragment roll-in">Write out your function argument names</li>
            <li class="fragment roll-in">Document your classes and methods</li>
            <li class="fragment roll-in">Refactor repeated lines of code into reusable functions or methods</li>
        </ul>
    </section>

    <section>
        <h2>PEP8</h2>
        <ul>
            <li class="fragment roll-in">Use 4 spaces per indentation level</li>
            <li class="fragment roll-in">Separate top-level function and class definitions with two blank lines</li>
            <li class="fragment roll-in">Method definitions inside a class are separated by a single blank line</li>
        </ul>
    </section>

    <section>
        <h2>The Word on Imports</h2>

        <p>The Order:</p>
        <ul>
            <li class="fragment roll-in">Standard library imports</li>
            <li class="fragment roll-in">Imports from core Django</li>
            <li class="fragment roll-in">Imports from third-party apps</li>
            <li class="fragment roll-in">Imports from the apps that you created as part of your Django project</li>
        </ul>
    </section>

    <section>
        <h2>The Word on Imports</h2>
        <img src="img/imports.png"/>
    </section>

    <section>
        <h2>Use Explicit Relative Imports</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/hardcoded_import.png">
    </section>

    <section>
        <h2>Use Explicit Relative Imports</h2>

        <p class="success">Do this:</p>
        <img src="img/explicit_import.png">
    </section>

    <section>
        <h2>Import Types</h2>
        <img src="img/import_types.png">
    </section>

    <section>
        <h3><span class="focus">Get into the habit of using explicit relative imports.</span></h3>
    </section>

    <section>
        <h2>Avoid Using Import *</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/import_star.png">
    </section>

    <section>
        <h2>Avoid Using Import *</h2>

        <p>The reason for this is <span class="focus">to avoid implicitly loading all of another Python module’s locals into</span>
            and over <span class="focus">our current module’s namespace</span>, which can produce <span class="focus">unpredictable</span>
            and sometimes <span class="focus">catastrophic
            results</span>.</p>
    </section>

    <section>
        <h2>Django Coding Style Guidelines</h2>

        <ul>
            <li class="fragment roll-in">Use underscores (the '_' character) in URL pattern names rather than dashes as
                this is friendlier to more IDEs and text editors.
            </li>
            <li class="fragment roll-in">For the same reason, use underscores rather than dashes in template block
                names.
            </li>
            <li class="fragment roll-in">Follow the commonly used naming pattern of <span class="focus">&lt;app_name&gt;_tags.py</span>
                for template tags
            </li>

        </ul>

        <p class="fragment roll-in"><a
                href="https://docs.djangoproject.com/en/1.6/internals/contributing/writing-code/coding-style/"
                target="_blank">Django Coding Style Guidelines</a></p>
    </section>

    <section>
        <h2>Summary</h2>

        <ul>
            <li class="fragment roll-in">Follow a <span class="focus">consistent coding style</span></li>
            <li class="fragment roll-in">Projects with <span class="focus">varying styles</span> are <span
                    class="focus">much harder to maintain</span>, <span class="focus">slowing development</span> and
                <span class="focus">increasing the chances of developer mistakes</span></li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>The Optimal Django Environment Setup</h2>
    </section>

    <section>
        <h2>Use the Same Database Engine Everywhere</h2>

        <p>A common developer pitfall is using SQLite3 for local development and PostgreSQL (or another database besides
            SQLite3) in production.</p>

        <p class="focus">They may not behave identical in different environments.</p>
        <ul>
            <li class="fragment roll-in">Fixtures Are Not a Magic Solution</li>
            <li class="fragment roll-in">You Can’t Examine an Exact Copy of Production Data Locally</li>
            <li class="fragment roll-in">Different Databases Have Different Field Types/Constraints</li>
        </ul>
    </section>

    <section>
        <h2>Use <span class="focus">Pip</span> and <span class="focus">Virtualenv</span></h2>
        <ul>
            <li class="fragment roll-in"><span class="focus">Pip</span> is used to manage and install Python packages
            </li>
            <li class="fragment roll-in">Without <span class="focus">virtualenv</span> you have to update dependency
                versions every time you switch projects
            </li>
            <li class="fragment roll-in">If that sounds tedious, keep in mind that most real Django projects have at
                least a dozen dependencies to maintain
            </li>
            <li class="fragment roll-in"><span class="focus">$ source ~/Envs/udemy/bin/activate</span></li>
        </ul>
    </section>

    <section>
        <h2>Install Django and Other Dependencies via <span class="focus">Pip</span></h2>
    </section>

    <section>
        <h2>Use a Version Control System</h2>
    </section>
</section>

<section>
    <section>
        <h2>How to Layout Django Projects</h2>
    </section>

    <section>
        <h2>Prefered Project Layout</h2>
        <img src="img/project_layout.png"/>
    </section>

    <section>
        <h2>Top Level: Repository Root</h2>
        <ul>
            <li class="fragment roll-in">The top-level <span class="focus">&lt;repository_root&gt;/</span> directory is
                the absolute root directory of the project
            </li>
            <li class="fragment roll-in">Place other critical components like the <span class="focus">README.rst</span>,
                <span class="focus">docs/</span> directory, <span class="focus">design/</span> directory, <span
                        class="focus">.gitignore</span>, <span class="focus">requirements.txt</span> files, and other
                <span class="focus">high-level files</span> that are required for deployment
            </li>
        </ul>
    </section>

    <section>
        <h2>Second Level: Django Project Root</h2>
        <ul>
            <li class="fragment roll-in">This directory contains the
                <span class="focus">&lt;configuration_root&gt;</span>, <span class="focus">media</span> and <span
                        class="focus">static</span> directories, a <span class="focus">site-wide templates</span>
                directory, as well as <span class="focus">Django
                    apps</span> specific to your particular project
            </li>
        </ul>
    </section>

    <section>
        <h2>Third Level: Configuration Root</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">&lt;configuration_root&gt;</span> directory is where the <span class="focus">settings module</span>
                and base <span class="focus">URLConf (urls.py)</span> are placed
            </li>
            <li class="fragment roll-in">
                This must be a valid Python package (containing an <span class="focus">__init__.py</span> module)
            </li>
        </ul>
    </section>

    <section>
        <h2>Sample Project Layout</h2>
        <img src="img/sample_project_layout.png"/>
    </section>

    <section>
        <h2>What About the Virtualenv?</h2>
        <ul>
            <li class="fragment roll-in">
                Put all our environments in one directory and all our projects in another
            </li>
        </ul>
        <img src="img/vm_dirs.png" class="fragment roll-in"/>
    </section>

    <section>
        <h3>TIP: Listing Current Dependencies</h3>

        <h3><span class="focus">pip freeze --local</span></h3>
    </section>

    <section>
        <h2>Template to Generate Layout</h2>

        <p class="focus">django-admin.py startproject
            --template=https://github.com/twoscoops/django-twoscoops-project/zipball/master --extension=py,rst,html
            $project-name</p>
    </section>

    <section>
        <h2>Summary</h2>

        <p class="focus">Whatever layout is chosen should be documented clearly</p>
    </section>

</section>

<section>
    <section>
        <h2>Fundamentals of Django App Design</h2>
    </section>

    <section>
        <h2>Definitions</h2>
        <ul>
            <li class="fragment roll-in"><span class="focus">A Django project</span> is a web application powered by the
                Django web framework
            </li>
            <li class="fragment roll-in"><span class="focus">Django apps</span> are small libraries designed to
                represent a single aspect of a
                project. A Django project is made up of many Django apps. Some of those apps are internal to the project
                and will never be reused; others are third-party Django packages.
            </li>
            <li class="fragment roll-in"><span class="focus">Third-party Django packages</span> are simply pluggable,
                reusable Django apps that have been packaged with the Python packaging tools.
            </li>
        </ul>
    </section>

    <section>
        <h2>The Golden Rule of Django App Design</h2>
        <blockquote class="focus">"Write programs that do one thing and do it well"</blockquote>
    </section>

    <section>
        <h2>The Golden Rule of Django App Design</h2>

        <p><span class="focus">Each app should be tightly focused on its task</span></p>

        <p>If an app can’t be explained in a single sentence of moderate length, or you need to say 'and' more than
            once, it probably means the app is <span class="focus">too big</span> and should be <span class="focus">broken up</span>
        </p>
    </section>

    <section>
        <h2>What to Name Your Django Apps</h2>
        <ul>
            <li class="fragment roll-in">When possible keep to single word names like <span class="focus">flavors</span>,
                <span class="focus">animals</span>, <span class="focus">blog</span>, <span class="focus">polls</span>,
                <span class="focus">dreams</span>, <span class="focus">estimates</span>, and <span class="focus">finances</span>.
                A good, obvious app name makes the project easier to maintain
            </li>
            <li class="fragment roll-in">As a general rule, the app’s name should be a <span class="focus">plural version of the app’s main model</span>,
                but there are many good exceptions to this rule, blog being one of the most common ones
            </li>
            <li class="fragment roll-in">Use valid, PEP 8-compliant, importable Python package names: <span
                    class="focus">short,
                all-lowercase names without numbers, dashes, periods, spaces, or special characters</span>. If needed
                for
                readability, you can <span class="focus">use underscores to separate words</span>, although the use of
                underscores is discouraged
            </li>
        </ul>
    </section>

    <section>
        <h2>When in Doubt, Keep Apps Small</h2>

        <p class="focus">Try and keep your apps small. Remember, it’s better to have many small apps than to have a few
            giant apps.</p>
    </section>

    <section>
        <h2>Summary</h2>
        <ul>
            <li class="fragment roll-in">Each Django app should be <span
                    class="focus">tightly-focused on its own task</span>, <span class="focus">possess a simple, easy-to-remember name</span>
            </li>
            <li class="fragment roll-in">If an app seems too complex, it should be <span class="focus">broken up into smaller apps</span>
            </li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>Settings and Requirements Files</h2>
    </section>

    <section>
        <h2>Best Practices</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">All settings files need to be version-controlled</span>
                <ul>
                    <li>This is especially true in production environments, where dates, times, and explanations for
                        settings changes absolutely must be tracked
                    </li>
                </ul>
            </li>
            <li class="fragment roll-in">
                <span class="focus">Don’t Repeat Yourself</span>
                <ul>
                    <li>You should inherit from a base settings file rather than cutting-and-pasting from one file to
                        another
                    </li>
                </ul>
            </li>
            <li class="fragment roll-in">
                <span class="focus">Keep secret keys safe</span>
                <ul>
                    <li>They should be kept out of version control</li>
                </ul>
            </li>
        </ul>
    </section>

    <section>
        <h2>Avoid Non-Versioned Local Settings</h2>

        <p class="focus">Let’s break up development, staging, test, and production settings into separate components
            that inherit from a common base file all tracked by version control</p>
    </section>

    <section>
        <h2>Using Multiple Settings Files</h2>
        <img src="img/settings_dir.png"/>
    </section>

    <section>
        <img src="img/settings_purpose.png"/>
    </section>

    <section>
        <h4>TIP: Multiple Files with Continuous Integration Servers</h4>

        <p>You’ll also want to have a <span class="focus">ci.py</span> module containing that server’s settings.</p>
    </section>

    <section>
        <h2>Run Server</h2>

        <p class="focus">python manage.py runserver --settings=udemy.settings.local</p>
    </section>

    <section>
        <h2>--settings or DJANGO_SETTINGS_MODULE</h2>
        <img src="img/settings_config.png"/>
    </section>

    <section>
        <h2>DEV Settings Example</h2>
        <img src="img/dev_settings.png"/>
    </section>

    <section>
        <h3>Keep Secret Keys Out with Environment Variables</h3>
        <ul>
            <li class="fragment roll-in">
                Secrets often should be just that: secret! Keeping them in version control means that everyone with
                repository access has access to them
            </li>
            <li class="fragment roll-in">
                Secret keys are configuration values, not code
            </li>
        </ul>
    </section>

    <section>
        <h2>To resolve this, our answer is to use <span class="focus">environment variables</span></h2>
    </section>

    <section>
        <h2>Benefits of Using EV</h2>
        <ul>
            <li class="fragment roll-in">
                Keeping secrets out of settings allows you to store every settings file in version control without
                hesitation. All of your Python code really should be stored in version control, including your settings
            </li>
            <li class="fragment roll-in">
                Instead of each developer maintaining an easily-outdated, copy-and-pasted version of the
                <span class="focus">local_settings.py.example</span> file for their own development purposes, everyone
                shares the same
                version-controlled <span class="focus">settings/local.py</span>
            </li>
            <li class="fragment roll-in">
                System administrators can rapidly deploy the project without having to modify files containing Python
                code
            </li>
            <li class="fragment roll-in">
                Most platforms-as-a-service recommend the use of environment variables for configuration and have
                built-in features for setting and managing them
            </li>
        </ul>
    </section>

    <section>
        <h2>Local Settings & Usage</h2>
        <img src="img/ev.png"/>
        <img src="img/ev_in_code.png"/>
    </section>

    <section>
        <h2>Using Multiple Requirements Files</h2>
        <ul>
            <li class="fragment roll-in">
                First create a <span class="focus">requirements/</span> directory in the <span class="focus">&lt;repository_root&gt;</span>
            </li>
            <li class="fragment roll-in">
                Then create <span class="focus">'.txt'</span> files that match the contents of your settings directory
            </li>
        </ul>
        <img src="img/multiple_reqs.png" class="fragment roll-in">
    </section>

    <section>
        <h2>Sample Config</h2>

        <p class="focus">base.txt</p>
        <img src="img/base_reqs.png">

        <p class="focus">local.txt</p>
        <img src="img/local_reqs.png">
    </section>

    <section>
        <h2>Install From Reqs File</h2>

        <p class="focus">for development env</p>
        <img src="img/install_from_req_local.png">

        <p class="focus">for production env</p>
        <img src="img/install_from_req_prod.png">
    </section>

    <section>
        <h2>Handling File Paths in Settings</h2>

        <h3><span class="focus">Don't hardcode your paths</span></h3>
    </section>

    <section>
        <h2>Hardcoded Paths</h2>

        <p class="alert">Don't do this:</p>
        <img src="img/hardcoded_paths.png">
    </section>

    <section>
        <h2>Relative Paths with Unipath</h2>

        <p class="success">Do this:</p>
        <img src="img/relative_paths.png">
    </section>

    <section>
        <h2>Relative Paths with Std Libs</h2>

        <p class="success">Do this:</p>
        <img src="img/relative_path_std.png">
    </section>

    <section>
        <h2>Summary</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">Everything except for critical security related values</span> ought to be <span
                    class="focus">tracked in version control</span>
            </li>
            <li class="fragment roll-in">
                Any project that’s destined for a real live production server is bound to need <span class="focus">multiple settings and
                requirements files</span>
            </li>
            <li class="fragment roll-in">
                The same thing applies to <span class="focus">requirements files</span>. Working with untracked
                dependency differences increases
                risk as much as untracked settings
            </li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>Database/Model Best Practices</h2>
    </section>

    <section>
        <h2>Basics</h2>
        <ul>
            <li class="fragment roll-in">
                Break Up Apps With Too Many Models
            </li>
            <li class="fragment roll-in">
                Don’t Drop Down to Raw SQL Until It’s Necessary
            </li>
            <li class="fragment roll-in">
                Add Indexes as Needed
            </li>
            <li class="fragment roll-in">
                Be Careful With Model Inheritance
            </li>
            <li class="fragment roll-in">
                Use South for Migrations
            </li>
        </ul>
    </section>

    <section>
        <h2>Condiser Adding Indexes?</h2>
        <ul>
            <li class="fragment roll-in">
                The index is used frequently, as in 10-25% of all queries
            </li>
            <li class="fragment roll-in">
                There is real data, or something that approximates real data, so we can analyze the results of indexing
            </li>
            <li class="fragment roll-in">
                We can run tests to determine if indexing generates an improvement in results
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">No Model Inheritance</span> if models have a common field, give both models that field
        </p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Makes it easiest to understand at a glance how Django models map to
                database tables
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> If there are a lot of fields duplicated across models, this can be hard
                to maintain
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">Abstract base classes</span> tables are only created for derived models
        </p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Having the common fields in an abstract parent class saves us from
                typing them more than once. We don’t get the overhead of extra tables and joins that are incurred from
                multi-table inheritance
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> We cannot use the parent class in isolation
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">Multi-table inheritance</span> tables are created for both parent and child. An implied
            <span class="focus">OneToOneField</span> links parent and child
        </p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Gives each model its own table, so that we can query either parent or
                child model. Also gives us the ability to get to a child object from a parent object: <span
                    class="focus">parent.child</span>
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> Adds substantial overhead since each query on a child table requires
                joins with all parent tables. <span class="focus">We strongly recommend against using multi-table inheritance</span>
            </li>
        </ul>
    </section>

    <section>
        <h2>Django Model Inheritance</h2>

        <p><span class="focus">Proxy Models</span> a table is only created for the original model</p>
        <ul>
            <li class="fragment roll-in">
                <span class="success">Pro:</span> Allows us to have an alias of a model with different Python behavior
            </li>
            <li class="fragment roll-in">
                <span class="alert">Con:</span> We cannot change the model’s fields
            </li>
        </ul>
    </section>

    <section>
        <h2>WARNING: Avoid Multi-Table Inheritance</h2>

        <p class="alert">Multi-table inheritance, sometimes called "concrete inheritance" is considered by the authors
            and many other
            developers to be a bad thing. We strongly recommend against using it</p>
    </section>

    <section>
        <h2>Django Model Design</h2>
    </section>

    <section>
        <h2>Design Basics</h2>
        <ul>
            <li class="fragment roll-in">
                Start Normalized
            </li>
            <li class="fragment roll-in">
                Cache Before Denormalizing
            </li>
            <li class="fragment roll-in">
                Denormalize Only if Absolutely Needed
            </li>
            <li class="fragment roll-in">
                When to Use Null and Blank
            </li>
        </ul>
    </section>

    <section>
        <h2>Null vs. Blank</h2>
        <img src="img/null_blank.png"/>
    </section>

    <section>
        <h2>Model Managers</h2>
    </section>

    <section>
        <h2>Model Managers Basics</h2>

        <p>Every time we use the Django ORM to query a model, we are using an interface called a <span class="focus">model manager</span>
            to interact with the database</p>

        <p>Django provides a default model manager for each model class, but we can define our own</p>
    </section>

    <section>
        <h2>Custom Model Manager</h2>
        <img src="img/custom_model_manager.png"/>
    </section>

    <section>
        <h2>Custom Model Manager</h2>
        <img src="img/model_manager_call.png"/>
    </section>

    <section>
        <h2>Summary</h2>
        <ul>
            <li class="fragment roll-in">
                Take the time to design models thoughtfully
            </li>
            <li class="fragment roll-in">
                Start normalized, and only denormalize if you’ve already explored other options thoroughly
            </li>
            <li class="fragment roll-in">
                Try to address your performance issues with caching
            </li>
            <li class="fragment roll-in">
                Don’t forget to use indexes. Add indexes when you have a better feel
            </li>
            <li class="fragment roll-in">
                If you decide to use model inheritance, inherit from abstract base classes rather than concrete models.
                You’ll save yourself from the confusion of dealing with implicit, unneeded joins
            </li>
            <li class="fragment roll-in">
                Use South to manage your data and schema migrations
            </li>
        </ul>
    </section>
</section>

<section>
    <section>
        <h2>Function- and Class- Based Views</h2>
    </section>

    <section>
        <h2>When to use FBV or CBVs</h2>
        <img src="img/fbc_vs_cbv.png"/>
    </section>

    <section>
        <h2>Keep View Logic Out of URLConfs</h2>
        <ul>
            <li class="fragment roll-in">
                The views modules should contain view logic
            </li>
            <li class="fragment roll-in">
                The URL modules should contain URL logic
            </li>
        </ul>
    </section>

    <section>
        <img src="img/bad_urls.png"/>
    </section>

    <section>
        <h2>Stick to Loose Coupling in <span class="focus">URLConfs</span></h2>
    </section>

    <section>
        <img src="img/good_view.png"/>
    </section>

    <section>
        <img src="img/good_urls.png"/>
    </section>

    <section>
        <h2>Best Practices</h2>
        <ul>
            <li class="fragment roll-in">
                <span class="focus">Don’t Repeat Yourself</span>: No argument or attribute is repeated between views
            </li>
            <li class="fragment roll-in">
                <span class="focus">Loose coupling</span>: We’ve removed the model and template names from the URLConf
                because views should be
                views and URLConfs should be URLConfs. We should be able to call our views from one or more URLConfs,
                and our approach lets us do just that
            </li>
            <li class="fragment roll-in">
                <span class="focus">URLConfs should do one thing and do it well: Related to our previous bullet, our URLConf is now focused
                primarily on just one thing</span>: URL routing. We aren’t tracking down view logic across both views
                and
                URLConfs, we just look in our views
            </li>
            <li class="fragment roll-in">
                <span class="focus">Our views benefit from being class-based</span>: Our views, by having a formal
                definition in the views module,
                can inherit from other classes. This means adding authentication, authorization, new content formats, or
                anything other business requirement tossed our way is much easier to handle
            </li>
            <li class="fragment roll-in">
                <span class="focus">Infinite flexibility</span>: Our views, by having a formal definition in the views
                module, can implement their
                own custom logic
            </li>
        </ul>
    </section>

    <section>
        <h2>Try to Keep Business Logic Out of Views</h2>
        <ul>
            <li class="fragment roll-in">
                Placing so much logic in our views made it much harder to deliver new formats such as PDF or REST API
            </li>
            <li class="fragment roll-in">
                Business logic is placed into easily reusable components, and called from within views, it makes
                extending components of the project to do more things much easier
            </li>
        </ul>
    </section>
</section>

<section>
    <section>
        <h2>Best Practices for Class-Based Views</h2>
    </section>

    <section>
        <h2>Guideline when writing CBVs</h2>
        <ul>
            <li class="fragment roll-in">
                Less view code is better
            </li>
            <li class="fragment roll-in">
                Never repeat code in views
            </li>
            <li class="fragment roll-in">
                Views should handle presentation logic. Try to keep business logic in models when possible, or in forms
                if you must
            </li>
            <li class="fragment roll-in">
                Keep your views simple
            </li>
            <li class="fragment roll-in">
                Keep your <span class="focus">mixins</span> simpler
            </li>
        </ul>
    </section>

    <section>
        <h2>Mixin Rules</h2>
        <ul>
            <li class="fragment roll-in">
                The base view classes provided by Django always go to the right
            </li>
            <li class="fragment roll-in">
                Mixins go to the left of the base view
            </li>
            <li class="fragment roll-in">
                Mixins should inherit from Python’s built-in object type
            </li>
        </ul>
    </section>

    <section>
        <img src="img/mixin.png"/>
    </section>

    <section>
        <h2>Django CBVs</h2>
        <img src="img/cbvs.png"/>
    </section>

    <section>
        <h3>Constraining Django CBV Access to Authenticated Users</h3>

        <p>PS: It uses <span class="focus">braces</span> lib</p>
        <img src="img/login_mixin.png">
    </section>
</section>

<section>
    <section>
        <h2>Things to Know About Forms</h2>
    </section>

    <section>
        <h2>Statistics</h2>
        <ul>
            <li class="fragment roll-in">
                95% of Django projects should use ModelForms
            </li>
            <li class="fragment roll-in">
                91% of all Django projects use ModelForms
            </li>
            <li class="fragment roll-in">
                80% of ModelForms require trivial logic
            </li>
            <li class="fragment roll-in">
                20% of ModelForms require complicated logic
            </li>
        </ul>
    </section>

    <section>
        <h2>Use the POST Method in HTML Forms</h2>

        <p class="focus">Every HTML form that alters data must submit its data via the POST method</p>

        <p class="focus">The only exception you’ll ever see to using POST in forms is with search forms, which typically
            submit queries that don’t result in any alteration of data.</p>
        <img src="img/form_post.png"/>
    </section>

    <section>
        <h3>Know How Form Validation Works</h3>

        <p>When you call <span class="focus">form.is_valid()</span>, a lot of things happen behind the scenes. The
            following things occur according to this workflow:</p>
        <ul>
            <li class="fragment roll-in">
                If the form has bound data, <span class="focus">form.is_valid()</span> calls the <span class="focus">form.full_clean()</span>
                method
            </li>
            <li class="fragment roll-in">
                <span class="focus">form.full_clean()</span> iterates through the form fields and each field validates
                itself:
                <ul>
                    <li>Data coming into the field is coerced into Python via the <span class="focus">to_python()</span>
                        method or raises a
                        <span class="focus">ValidationError</span>
                    </li>
                    <li>Data is validated against field-specific rules, including custom validators. Failure raises a
                        <span class="focus">ValidationError</span>
                    </li>
                    <li>If there are any custom <span class="focus">clean_
                        &lt;field&gt;()</span> methods in the form, they are called at this time
                    </li>
                </ul>
            </li>
            <li class="fragment roll-in">
                <span class="focus">form.full_clean()</span> executes the <span class="focus">form.clean()</span> method
            </li>
            <li class="fragment roll-in">
                If it’s a ModelForm instance, <span class="focus">form._post_clean()</span> does the following:
                <ul>
                    <li>Sets <span class="focus">ModelForm</span> data to the Model instance, regardless of whether
                        <span class="focus">form.is_valid()</span> is <span class="focus">True</span> or
                        <span class="focus">False</span>
                    </li>
                    <li>Calls the model’s <span class="focus">clean()</span> method. For reference, saving a model
                        instance through the ORM does
                        not call the model’s <span class="focus">clean()</span> method
                    </li>
                </ul>
            </li>
        </ul>
    </section>

    <section>
        <h3>Form Data Is Saved to the Form, Then the Model Instance</h3>
        <ul>
            <li class="fragment roll-in">
                First, form data is saved to the form instance
            </li>
            <li class="fragment roll-in">
                Later, form data is saved to the model instance
            </li>
        </ul>
    </section>

    <section>
        <h2>Summary</h2>

        <p class="focus">Once you dig into forms, keep yourself focused on clarity of code and testability</p>
    </section>

</section>

<section>
    <section>
        <h2>Building REST APIs in Django</h2>
    </section>
</section>

<section>
    <section>
        <h2>Templates: Best Practices</h2>
    </section>
</section>

<section>
    <section>
        <h2>Template Tangs and Filters</h2>
    </section>
</section>

<section>
    <section>
        <h2>Trade offs of Replacing Core Components</h2>
    </section>
</section>

<section>
    <section>
        <h2>Working with Django Admin</h2>
    </section>
</section>

<section>
    <section>
        <h2>Dealing with the User Model</h2>
    </section>
</section>

<section>
    <section>
        <h2>Third Party Packages</h2>
    </section>
</section>

<section>
    <section>
        <h2>Testing</h2>
    </section>
</section>

<section>
    <section>
        <h2>Documentation</h2>
    </section>
</section>

<section>
    <section>
        <h2>Finding and Reducing Bottlenecks</h2>
    </section>
</section>

<section>
    <section>
        <h2>Security Best Practices</h2>
    </section>
</section>

<section>
    <section>
        <h2>Logging</h2>
    </section>
</section>

<section>
    <section>
        <h2>Signals: Use Cases and Avoidance Techniques</h2>
    </section>
</section>

<section>
    <section>
        <h2>Random Utilities</h2>
    </section>
</section>

<section>
    <section>
        <h2>Deploying Django Projects</h2>
    </section>
</section>

</div>
</div>

<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>

<script>
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme,
        transition: Reveal.getQueryHash().transition || 'zoom', // default/cube/page/concave/zoom/linear/fade/none

        dependencies: [
            { src: 'reveal/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            } },
            { src: 'reveal/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'reveal/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            } },
            { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function () {
                return !!document.body.classList;
            } },
            { src: 'reveal/plugin/notes/notes.js', async: true, condition: function () {
                return !!document.body.classList;
            } }
        ]
    });
</script>
</body>
</html>
